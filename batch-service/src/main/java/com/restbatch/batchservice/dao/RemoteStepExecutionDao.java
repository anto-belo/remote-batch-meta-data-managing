package com.restbatch.batchservice.dao;

import com.restbatch.batchservice.client.StepExecutionDaoClient;
import com.restbatch.batchservice.dto.holder.StepExecutionHolder;
import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.batch.core.JobExecution;
import org.springframework.batch.core.JobInstance;
import org.springframework.batch.core.StepExecution;
import org.springframework.batch.core.repository.dao.StepExecutionDao;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;

/**
 * @author Anton Belousov
 * @since 0.0.1-SNAPSHOT
 */
@Slf4j
public class RemoteStepExecutionDao extends AbstractBatchMetaDataDao
    implements StepExecutionDao, InitializingBean {

  @Setter
  private StepExecutionDaoClient client;
  private int exitMessageLength = DEFAULT_EXIT_MESSAGE_LENGTH;

  /**
   * Public setter for the exit message length in database. Do not set this if you haven't modified
   * the schema.
   *
   * @param exitMessageLength the exitMessageLength to set
   */
  public void setExitMessageLength(int exitMessageLength) {
    this.exitMessageLength = exitMessageLength;
  }

  @Override
  public void afterPropertiesSet() {
    Assert.notNull(client, "StepExecutionDaoClient must not be null.");
  }

  /**
   * Save a StepExecution. A unique id will be generated by the stepExecutionIncrementer, and then
   * set in the StepExecution. All values will then be stored via an INSERT statement.
   *
   * @see org.springframework.batch.core.repository.dao.StepExecutionDao#saveStepExecution(StepExecution)
   */
  @Override
  public void saveStepExecution(StepExecution stepExecution) {
    client.saveStepExecution(buildStepExecutionParameters(stepExecution));
  }

  /**
   * Batch insert StepExecutions
   *
   * @see org.springframework.batch.core.repository.dao.StepExecutionDao#saveStepExecutions(Collection)
   */
  @Override
  public void saveStepExecutions(final Collection<StepExecution> stepExecutions) {
    Assert.notNull(stepExecutions, "Attempt to save a null collection of step executions");

    client.saveStepExecutions(
        stepExecutions.stream()
            .map(this::buildStepExecutionParameters)
            .collect(Collectors.toList()));
  }

  private StepExecutionHolder buildStepExecutionParameters(StepExecution stepExecution) {
    Assert.isNull(stepExecution.getId(),
        "to-be-saved (not updated) StepExecution can't already have an id assigned");
    Assert.isNull(stepExecution.getVersion(),
        "to-be-saved (not updated) StepExecution can't already have a version assigned");
    validateStepExecution(stepExecution);
    stepExecution.setId(client.nextStepExecutionId());
    stepExecution.incrementVersion(); //Should be 0
    String exitDescription = truncateExitDescription(
        stepExecution.getExitStatus().getExitDescription());

    return StepExecutionHolder.builder()
        .id(stepExecution.getId())
        .version(stepExecution.getVersion())
        .stepName(stepExecution.getStepName())
        .jobExecutionId(stepExecution.getJobExecutionId())
        .startTime(stepExecution.getStartTime())
        .endTime(stepExecution.getEndTime())
        .status(stepExecution.getStatus())
        .commitCount(stepExecution.getCommitCount())
        .readCount(stepExecution.getReadCount())
        .filterCount(stepExecution.getFilterCount())
        .writeCount(stepExecution.getWriteCount())
        .exitCode(stepExecution.getExitStatus().getExitCode())
        .exitDescription(exitDescription)
        .readSkipCount(stepExecution.getReadSkipCount())
        .writeSkipCount(stepExecution.getWriteSkipCount())
        .processSkipCount(stepExecution.getWriteSkipCount())
        .rollbackCount(stepExecution.getRollbackCount())
        .lastUpdated(stepExecution.getLastUpdated())
        .build();
  }

  /**
   * Validate StepExecution. At a minimum, JobId, StartTime, and Status cannot be null. EndTime can
   * be null for an unfinished job.
   */
  private void validateStepExecution(StepExecution stepExecution) {
    Assert.notNull(stepExecution, "stepExecution is required");
    Assert.notNull(stepExecution.getStepName(), "StepExecution step name cannot be null.");
    Assert.notNull(stepExecution.getStartTime(), "StepExecution start time cannot be null.");
    Assert.notNull(stepExecution.getStatus(), "StepExecution status cannot be null.");
  }

  @Override
  public void updateStepExecution(StepExecution stepExecution) {

    validateStepExecution(stepExecution);
    Assert.notNull(stepExecution.getId(),
        "StepExecution Id cannot be null. StepExecution must saved"
            + " before it can be updated.");

    // Do not check for existence of step execution considering
    // it is saved at every commit point.

    String exitDescription = truncateExitDescription(
        stepExecution.getExitStatus().getExitDescription());

    // Attempt to prevent concurrent modification errors by blocking here if
    // someone is already trying to do it.
    synchronized (stepExecution) {
      int version = stepExecution.getVersion() + 1;
      StepExecutionHolder holder = StepExecutionHolder.builder()
          .startTime(stepExecution.getStartTime())
          .endTime(stepExecution.getEndTime())
          .status(stepExecution.getStatus())
          .commitCount(stepExecution.getCommitCount())
          .readCount(stepExecution.getReadCount())
          .filterCount(stepExecution.getFilterCount())
          .writeCount(stepExecution.getWriteCount())
          .exitCode(stepExecution.getExitStatus().getExitCode())
          .exitDescription(exitDescription)
          .updateVersion(version)
          .readSkipCount(stepExecution.getReadSkipCount())
          .processSkipCount(stepExecution.getProcessSkipCount())
          .writeSkipCount(stepExecution.getWriteSkipCount())
          .rollbackCount(stepExecution.getRollbackCount())
          .lastUpdated(stepExecution.getLastUpdated())
          .id(stepExecution.getId())
          .version(stepExecution.getVersion())
          .build();
      int count = client.updateStepExecution(holder);

      // Avoid concurrent modifications...
      if (count == 0) {
        int currentVersion = client.getStepExecutionVersion(stepExecution.getId());
        throw new OptimisticLockingFailureException("Attempt to update step execution id="
            + stepExecution.getId() + " with wrong version (" + stepExecution.getVersion()
            + "), where current version is " + currentVersion);
      }

      stepExecution.incrementVersion();
    }
  }

  /**
   * Truncate the exit description if the length exceeds {@link #DEFAULT_EXIT_MESSAGE_LENGTH}.
   *
   * @param description the string to truncate
   * @return truncated description
   */
  private String truncateExitDescription(String description) {
    if (description != null && description.length() > exitMessageLength) {
      if (log.isDebugEnabled()) {
        log.debug("Truncating long message before update of StepExecution, original message is: "
            + description);
      }
      return description.substring(0, exitMessageLength);
    } else {
      return description;
    }
  }

  @Override
  @Nullable
  public StepExecution getStepExecution(JobExecution jobExecution, Long stepExecutionId) {
    List<StepExecutionHolder> executions = client.getStepExecution(jobExecution.getId(),
        stepExecutionId);

    Assert.state(executions.size() <= 1,
        "There can be at most one step execution with given name for single job execution");
    if (executions.isEmpty()) {
      return null;
    } else {
      StepExecutionHolder holder = executions.get(0);
      holder.setJobExecution(jobExecution);
      return holder.getTarget();
    }
  }

  @Override
  public StepExecution getLastStepExecution(JobInstance jobInstance, String stepName) {
    StepExecutionHolder holder = client.getLastStepExecution(jobInstance.getInstanceId(), stepName);
    return Objects.nonNull(holder) ? holder.getTarget() : null;
  }

  @Override
  public void addStepExecutions(JobExecution jobExecution) {
    jobExecution.addStepExecutions(
        client.getStepExecutions(jobExecution.getId()).stream()
            .peek(holder -> holder.setJobExecution(jobExecution))
            .map(StepExecutionHolder::getTarget)
            .collect(Collectors.toList()));
  }

  @Override
  public int countStepExecutions(JobInstance jobInstance, String stepName) {
    return client.countStepExecutions(jobInstance.getInstanceId(), stepName);
  }
}
